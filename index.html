<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Decoherence Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body { margin:0; padding:0; background:#0a0a0a; color:#e6ffe6; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; height:100%; }
    #game-container { width:100vw; height:100vh; overflow:hidden; position:relative; touch-action:none; }
    .hud {
      position:absolute; top:10px; left:10px; right:10px; display:flex; justify-content:space-between;
      font-weight:600; letter-spacing:.02em; pointer-events:none; text-shadow:0 1px 2px rgba(0,0,0,.6);
    }
    .center-overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:auto; }
    .btn { pointer-events:auto; padding:.6rem 1rem; border:1px solid #00ff88; color:#00ff88; background:transparent; border-radius:6px; text-transform:uppercase; letter-spacing:.08em; cursor:pointer }
    .btn:hover{ background:#002a20 }
    .panel {
      background:rgba(0,0,0,.55); border:1px solid #003c2d; padding:1rem 1.25rem; border-radius:10px; backdrop-filter:blur(6px);
      max-width:min(520px,92vw); color:#c7ffec; text-align:center;
    }
    .hidden{ display:none }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="game-container"></div>

  <div class="hud" id="hud">
    <div>Score: <span id="score">0</span> &nbsp;•&nbsp; Mult: <span id="mult">1.0×</span></div>
    <div>Tier: <span id="tier">1</span> &nbsp;•&nbsp; Dist: <span id="dist">0m</span></div>
  </div>

  <div id="overlay-start" class="center-overlay">
    <div class="panel">
      <h2 style="margin:.25rem 0 0">Decoherence Runner</h2>
      <p style="opacity:.8;margin:.25rem 0 1rem">A minimal lane-runner about observation, collapse, and flow.</p>
      <p style="font-size:.9rem; opacity:.8; margin:.25rem 0 1rem">
        Controls: <strong>Swipe</strong> left/right or <strong>A/D</strong>/<strong>←/→</strong> to change lane • <strong>Tap</strong> or <strong>Space</strong> to jump
      </p>
      <button id="btn-start" class="btn">Tap or Press to Start</button>
    </div>
  </div>

  <div id="overlay-gameover" class="center-overlay hidden">
    <div class="panel">
      <h3 style="margin:.25rem 0">Collapsed.</h3>
      <p id="final-stats" style="opacity:.85;margin:.25rem 0 1rem"></p>
      <button id="btn-restart" class="btn">Run Again</button>
    </div>
  </div>

  <!-- Keep only ONE copy of this (optional). Remove duplicates if you had them. -->
  <script>
  (function(){ "use strict";
    // Minimal placeholder to match your earlier structure (does nothing).
  })();
  </script>

  <script>
  // ============ Utility ============
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const LANE_COUNT = 4;
  const BASE_SPEED = 220;     // px/sec world speed
  const LANE_SPACING = 68;    // px between lanes (scaled later)
  const PLAYER_Y_RATIO = 0.70;
  const TARGET_FPS = 60;

  // Simple seeded RNG for daily seeds
  function makeRng(seed) {
    let s = seed >>> 0;
    return () => { s ^= s << 13; s ^= s >>> 17; s ^= s << 5; return (s >>> 0) / 4294967296; };
  }

  // ============ Audio (Layered) ============
  class AudioManager {
    constructor() { this.ctx = null; this.layers = null; this.started = false; }
    isSupported() { return !!(window.AudioContext || window.webkitAudioContext); }
    async start() {
      if (this.started) return;
      if (!this.isSupported()) return;
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      const mk = () => this.ctx.createGain();
      const gMaster = mk(), gPad = mk(), gArp = mk(), gNoise = mk();
      gMaster.connect(this.ctx.destination);
      gPad.connect(gMaster); gArp.connect(gMaster); gNoise.connect(gMaster);
      gMaster.gain.value = 0.5; gPad.gain.value = 0.18; gArp.gain.value = 0.0; gNoise.gain.value = 0.0;

      // Pad
      const pad1 = this.ctx.createOscillator(), pad2 = this.ctx.createOscillator();
      pad1.type='sawtooth'; pad2.type='sawtooth'; pad1.frequency.value=110; pad2.frequency.value=112.2;
      pad1.connect(gPad); pad2.connect(gPad); pad1.start(); pad2.start();

      // Arp
      const arp = this.ctx.createOscillator(); arp.type='square'; arp.frequency.value=0; // silent baseline
      const gArpEnv = mk(); gArpEnv.gain.value = 0; arp.connect(gArpEnv); gArpEnv.connect(gArp); arp.start();

      // Noise
      const noiseBuf = this._whiteNoiseBuffer(this.ctx);
      const noise = this.ctx.createBufferSource(); noise.buffer=noiseBuf; noise.loop=true;
      const hp = this.ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200;
      noise.connect(hp); hp.connect(gNoise); noise.start();

      this.layers = { gMaster, gPad, gArp, gNoise, arp, gArpEnv };
      this.started = true;
    }
    _whiteNoiseBuffer(ctx){
      const len = ctx.sampleRate * 2, buf = ctx.createBuffer(1, len, ctx.sampleRate), data = buf.getChannelData(0);
      for (let i=0;i<len;i++) data[i] = (Math.random()*2-1)*0.15;
      return buf;
    }
    setTier(t){
      if (!this.layers || !this.ctx) return;
      const now = this.ctx.currentTime;
      const { gPad, gArp, gNoise } = this.layers;
      gPad.gain.setTargetAtTime(0.16 + 0.06 * Math.min(3, t-1), now, 0.25);
      gArp.gain.setTargetAtTime(t >= 2 ? 0.08 : 0.0, now, 0.25);
      gNoise.gain.setTargetAtTime(t >= 3 ? 0.05 : 0.0, now, 0.25);
    }
    blip(){
      if (!this.layers || !this.ctx) return;
      const { gArpEnv } = this.layers; const now = this.ctx.currentTime;
      gArpEnv.gain.cancelScheduledValues(now);
      gArpEnv.gain.setValueAtTime(0.0, now);
      gArpEnv.gain.linearRampToValueAtTime(0.25, now + 0.02);
      gArpEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
    }
    hit(){
      if (!this.layers || !this.ctx) return;
      const { gMaster } = this.layers; const now = this.ctx.currentTime;
      gMaster.gain.setTargetAtTime(0.15, now, 0.01);
      gMaster.gain.setTargetAtTime(0.5, now + 0.12, 0.08);
    }
  }

  // ============ Player FSM ============
  class PlayerController {
    constructor(scene, sprite, laneXFor) {
      this.scene = scene; this.sprite = sprite; this.laneXFor = laneXFor;
      this.state = 'IDLE'; // IDLE, LANE_MOVE, JUMP, HITSTUN
      this.currentLane = 1; // 0..LANE_COUNT-1
      this.targetLane = 1;
      this.vy = 0;
      this.jumpGravity = 500;
      this.jumpImpulse = -300;
      scene.physics.add.existing(sprite);
      sprite.body.setAllowGravity(false); // manual jump physics
      sprite.body.setCircle(12, 4, 12);   // forgiving rounded hitbox
    }
    setLane(n){
      if (this.state === 'HITSTUN') return;
      n = Phaser.Math.Clamp(n, 0, LANE_COUNT-1);
      if (n === this.currentLane) return;
      this.targetLane = n;
      this.state = 'LANE_MOVE';
      const x = this.laneXFor(n);
      this.scene.tweens.add({
        targets: this.sprite, x, duration: 120, ease: 'Sine.Out',
        onComplete: () => {
          this.currentLane = n;
          if (this.state === 'LANE_MOVE') this.state = 'IDLE';
        }
      });
    }
    jump(){
      if (this.state === 'HITSTUN') return;
      if (this.state === 'JUMP') return;
      this.state = 'JUMP';
      this.vy = this.jumpImpulse;
    }
    update(dt, groundY){
      if (this.state === 'JUMP'){
        this.vy += this.jumpGravity * dt;
        this.sprite.y += this.vy * dt;
        if (this.sprite.y >= groundY){
          this.sprite.y = groundY; this.vy = 0; this.state = 'IDLE';
        }
      }
    }
    hitstun(){
      this.state = 'HITSTUN';
      this.scene.time.delayedCall(320, () => { /* remain until scene handles game over */ });
    }
  }

  // ============ Play Scene ============
  class PlayScene extends Phaser.Scene {
    constructor() {
      super('Play');
      this.audio = new AudioManager();
      this.seed = this._dailySeed();
      this.rng = makeRng(this.seed);
      this.score = 0; this.mult = 1.0; this.distance = 0;
      this.tier = 1; this.worldSpeed = BASE_SPEED;
      this.spawnTimer = 0; this.spawnInterval = 1300;
      this.nearMissWindow = 42; // px
      this.gameOverFlag = false;

      // gesture state
      this.gestureActiveId = null;
      this.touchStartX = 0; this.touchStartY = 0; this.touchStartT = 0;
      this.swipeThreshold = 40;     // px
      this.swipeTimeMax = 500;      // ms
      this.tapMoveTolerance = 12;   // px
    }

    _dailySeed(){
      const d = new Date(); const k = `${d.getUTCFullYear()}-${d.getUTCMonth()+1}-${d.getUTCDate()}`;
      let h = 2166136261>>>0; for (let i=0;i<k.length;i++){ h^=k.charCodeAt(i); h = Math.imul(h, 16777619); }
      return h>>>0;
    }

    preload() { /* textures generated in create */ }

    create() {
      // Scene refs
      this.cameras.main.setBackgroundColor('#0a0a0a');
      this.physics.world.setBounds(0,0,innerWidth,innerHeight);

      // Layout
      this.laneSpacing = LANE_SPACING * (innerWidth/1280) * (DPR>1?1.0:1.0);
      this.baseX = innerWidth * 0.30;
      this.groundY = innerHeight * PLAYER_Y_RATIO;

      // Procedural textures
      this._createProceduralTextures();

      // Background dots
      this.bgDots = [];
      for (let i=0;i<24;i++){
        const s = this.add.rectangle(Math.random()*innerWidth*2, Math.random()*innerHeight, 1+Math.random()*3, 1+Math.random()*3, 0x003322, 0.22);
        this.bgDots.push(s);
      }

      // Lanes
      this.lanes = [];
      for (let i=0;i<LANE_COUNT;i++){
        const x = this._laneX(i);
        const lane = this.add.rectangle(x, this.groundY, 2, 280, 0x003322, 0.2);
        lane.setVisible(false);
        this.lanes.push(lane);
      }

      // Player
      this.player = this.add.sprite(this.baseX, this.groundY, 'player').setScale(1);
      this.playerController = new PlayerController(this, this.player, (i)=>this._laneX(i));

      // Pools
      this.obstacleGroup = this.add.group({ classType: Phaser.GameObjects.Sprite, runChildUpdate: false });
      this.activeObstacles = [];

      // Physics overlap
      this.physics.add.overlap(this.player, this.obstacleGroup, this._onHit, null, this);

      // Input (keyboard)
      this.cursors = this.input.keyboard.createCursorKeys();
      this.keys = this.input.keyboard.addKeys('A,D,SPACE');

      // Input (mobile gestures)
      this._initGestures();

      // UI hooks & audio kickoff
      this._bindUI();
      const kickAudio = async () => { await this.audio.start(); this.audio.setTier(this.tier); this.input.off('pointerdown', kickAudio); };
      this.input.on('pointerdown', kickAudio);

      // Start values
      this.timeSinceStart = 0;
      this.lastTierUp = 0;
    }

    _initGestures(){
      // Prevent browser gestures on iOS/Android
      this.input.topOnly = true;

      this.input.on('pointerdown', (p) => {
        if (this.gestureActiveId !== null) return; // track single pointer
        this.gestureActiveId = p.id;
        this.touchStartX = p.x; this.touchStartY = p.y; this.touchStartT = performance.now();
      });

      this.input.on('pointerup', (p) => {
        if (p.id !== this.gestureActiveId) return;
        const dx = p.x - this.touchStartX;
        const dy = p.y - this.touchStartY;
        const dt = performance.now() - this.touchStartT;

        const absX = Math.abs(dx), absY = Math.abs(dy);

        // Swipe: horizontal, fast enough, larger than vertical
        if (absX >= this.swipeThreshold && absX > absY && dt <= this.swipeTimeMax) {
          if (dx < 0) this.playerController.setLane(this.playerController.currentLane - 1);
          else        this.playerController.setLane(this.playerController.currentLane + 1);
        } else {
          // Tap: minimal movement
          if (absX <= this.tapMoveTolerance && absY <= this.tapMoveTolerance) {
            this.playerController.jump(); this.audio.blip();
          }
        }
        this.gestureActiveId = null;
      });

      // Optionally cancel if pointer leaves
      this.input.on('pointerout',  (p)=>{ if (p.id===this.gestureActiveId) this.gestureActiveId=null; });
      this.input.on('pointercancel',(p)=>{ if (p.id===this.gestureActiveId) this.gestureActiveId=null; });
    }

    _bindUI(){
      const startBtn = document.getElementById('btn-start');
      const startOverlay = document.getElementById('overlay-start');
      const gameOverOverlay = document.getElementById('overlay-gameover');
      const restartBtn = document.getElementById('btn-restart');

      const startGame = () => {
        startOverlay.classList.add('hidden');
        this.gameOverFlag = false;
        this.resetRun();
      };
      startBtn.onclick = startGame;
      restartBtn.onclick = () => {
        gameOverOverlay.classList.add('hidden');
        this.scene.restart();
        setTimeout(()=>startGame(), 0);
      };
      // Enter/Space start
      window.addEventListener('keydown',(e)=>{
        if (!startOverlay.classList.contains('hidden') && (e.code==='Space'||e.code==='Enter')) { startBtn.click(); }
      }, {passive:false});
    }

    resetRun(){
      // Clear pools
      this.activeObstacles.forEach(o => this._recycleObstacle(o));
      this.activeObstacles.length = 0;

      // Scores & pacing
      this.score = 0; this.mult = 1.0; this.distance = 0;
      this.tier = 1; this.worldSpeed = BASE_SPEED; this.spawnInterval = 1300;
      this.spawnTimer = 0; this.timeSinceStart = 0; this.lastTierUp = 0;

      // Place player
      this.player.x = this.baseX; this.player.y = this.groundY;
      this.playerController.currentLane = 1; this.playerController.targetLane = 1; this.playerController.state = 'IDLE';

      // Update audio tier
      this.audio.setTier(this.tier);
      this._updateHUD();
    }

    update(time, deltaMs){
      if (this.gameOverFlag) return;

      const dt = Math.min(0.05, deltaMs/1000);
      this.timeSinceStart += dt;

      // Keyboard polling
      const left = this.cursors.left.isDown || this.keys.A.isDown;
      const right = this.cursors.right.isDown || this.keys.D.isDown;
      const jump = Phaser.Input.Keyboard.JustDown(this.cursors.space) || Phaser.Input.Keyboard.JustDown(this.keys.SPACE);

      if (left)  this.playerController.setLane(this.playerController.currentLane - 1);
      if (right) this.playerController.setLane(this.playerController.currentLane + 1);
      if (jump)  { this.playerController.jump(); this.audio.blip(); }

      // Player FSM
      this.playerController.update(dt, this.groundY);

      // Parallax background
      for (const d of this.bgDots){
        d.x -= (this.worldSpeed * 0.25) * dt;
        if (d.x < -10){ d.x = innerWidth + 10; d.y = Math.random() * innerHeight; }
      }

      // Difficulty ramp
      if (this.timeSinceStart - this.lastTierUp > 20 && this.tier < 4){
        this.tier += 1; this.lastTierUp = this.timeSinceStart;
        this.worldSpeed += 40;
        this.audio.setTier(this.tier);
        this._pulseHUD();
      }

      // Spawning (pattern-based)
      this.spawnTimer += dt*1000;
      if (this.spawnTimer >= this.spawnInterval){
        this._spawnPattern(this.tier);
        this.spawnTimer = 0;
        this.spawnInterval = Math.max(850, this.spawnInterval - (30 + 10*this.tier));
      }

      // Move & recycle obstacles
      const v = this.worldSpeed * dt;
      for (let i=this.activeObstacles.length-1;i>=0;i--){
        const s = this.activeObstacles[i];
        s.x -= v;
        if (!s._nearMissed && Math.abs(s.x - this.player.x) < this.nearMissWindow && s.lane === this.playerController.currentLane){
          s._nearMissed = true;
          this._nearMissFeedback();
          this._addScore(15);
        }
        if (s.x < -100){
          this._recycleObstacle(s);
          this.activeObstacles.splice(i,1);
          this._addScore(10 * this.mult);
        }
      }

      // Distance/score over time
      this.distance += this.worldSpeed * dt * 0.05;
      this._updateHUD();
    }

    // -------- Patterns & Fairness --------
    _spawnPattern(tier){
      const PATTERNS = [
        { lanes:[0,2], stagger:0 },
        { lanes:[1,3], stagger:0 },
        { lanes:[1,2], stagger:20 },
        { lanes:[0,1,2], stagger:34 },
        { lanes:[1,2,3], stagger:34 },
        { lanes:[0,3], stagger:0 },
      ];
      const bank = PATTERNS.slice(0, 2 + Math.min(4, tier+1));
      const p = Phaser.Utils.Array.GetRandom(bank);
      const baseX = innerWidth + 60;
      let x = baseX;
      const minGapX = this.player.x + 160;

      for (const l of p.lanes){
        if (x < minGapX) x = minGapX + 30 + (this.rng()*30|0);
        const s = this._getObstacle(x, l);
        this.activeObstacles.push(s);
        x += (p.stagger||0);
      }
    }

    // -------- Pools --------
    _getObstacle(x, lane){
      let s = this.obstacleGroup.getFirstDead();
      if (!s){ s = this.add.sprite(x, this.groundY, 'obstacle'); this.obstacleGroup.add(s); this.physics.add.existing(s); s.body.setImmovable(true); s.body.setAllowGravity(false); }
      s.setActive(true).setVisible(true);
      s.x = x; s.y = this.groundY; s.lane = lane; s._nearMissed = false;
      s.body.setSize(18, 18, true);
      return s;
    }
    _recycleObstacle(s){ s.setActive(false).setVisible(false); }

    // -------- Collisions --------
    _onHit(player, obstacle){
      if (this.gameOverFlag) return;
      this._hitFeedback();
      this.playerController.hitstun();
      this._gameOver();
    }

    // -------- Feedback --------
    _hitFeedback(){
      this.time.timeScale = 0.05;
      this.cameras.main.shake(160, 0.004);
      this.audio.hit();
      this.time.delayedCall(110, ()=> { this.time.timeScale = 1; });
    }
    _nearMissFeedback(){
      this.cameras.main.shake(90, 0.0015);
      this.mult = Math.min(5.0, +(this.mult + 0.05).toFixed(2));
      this.audio.blip();
      const multEl = document.getElementById('mult');
      multEl.style.color = '#ff66cc';
      setTimeout(()=>multEl.style.color='', 160);
    }

    // -------- HUD & UI --------
    _updateHUD(){
      document.getElementById('score').textContent = Math.floor(this.score);
      document.getElementById('mult').textContent  = `${this.mult.toFixed(1)}×`;
      document.getElementById('tier').textContent  = this.tier;
      document.getElementById('dist').textContent  = `${Math.floor(this.distance)}m`;
    }
    _pulseHUD(){
      const tierEl = document.getElementById('tier');
      tierEl.style.color = '#00ff88';
      tierEl.style.textShadow = '0 0 8px rgba(0,255,136,.6)';
      setTimeout(()=>{ tierEl.style.color=''; tierEl.style.textShadow=''; }, 400);
    }
    _addScore(v){ this.score += v * this.mult; }

    // -------- Geometry helpers --------
    _laneX(i){ return this.baseX + i * this.laneSpacing; }

    // -------- Procedural textures --------
    _createProceduralTextures(){
      const g = this.add.graphics();
      // Player
      g.clear(); g.fillStyle(0x00ff88); g.fillRoundedRect(0,0,32,48,8);
      g.fillStyle(0x003322); g.fillRoundedRect(4,12,24,20,4);
      g.fillStyle(0x001100); g.fillCircle(16,32,6);
      g.generateTexture('player',32,48);
      // Obstacle
      g.clear(); g.fillStyle(0xff0088); g.fillRoundedRect(0,0,24,24,4);
      g.fillStyle(0x440022); g.fillRoundedRect(2,2,20,20,2);
      g.generateTexture('obstacle',24,24);
      g.destroy();
    }

    // -------- Game over --------
    _gameOver(){
      this.gameOverFlag = true;
      const fs = document.getElementById('final-stats');
      fs.textContent = `Score ${Math.floor(this.score)} • Tier ${this.tier} • Distance ${Math.floor(this.distance)}m`;
      document.getElementById('overlay-gameover').classList.remove('hidden');
    }
  }

  // ============ Boot & Game Config ============
  const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: '#0a0a0a',
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: [PlayScene],
    parent: 'game-container',
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH }
  };
  const game = new Phaser.Game(config);

  // Resize handling
  window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
    const s = game.scene.getScene('Play');
    if (s){
      s.laneSpacing = LANE_SPACING * (innerWidth/1280);
      s.baseX = innerWidth * 0.30;
      s.groundY = innerHeight * PLAYER_Y_RATIO;
      if (s.player){ s.player.y = s.groundY; }
      if (s.lanes){
        for (let i=0;i<LANE_COUNT;i++){
          const lane = s.lanes[i];
          lane.x = s._laneX(i); lane.y = s.groundY;
        }
      }
    }
  }, {passive:true});

  // Prevent iOS long-press select / context menu artifacts
  document.addEventListener('contextmenu', e => e.preventDefault(), {passive:false});
  </script>
</body>
</html>
